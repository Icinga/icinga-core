#!/bin/sh
#
### BEGIN INIT INFO
# Provides:          ido2db
# Required-Start:    $remote_fs $syslog $named $network $time
# Required-Stop:     $remote_fs $syslog $named $network
# X-Start-Before:    icinga
# X-Stop-After:      icinga
# Should-Start:      mysql postgresql
# Should-Stop:       mysql postgresql
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Icinga IDO2DB Initscript
# Description: 	     Icinga Data Out Daemon
### END INIT INFO

# chkconfig: 345 98 01
#
# File : ido2db
#
# Author : Jorge Sanchez Aymar (jsanchez@lanchile.cl)
#
# Changelog :
#
# 1999-07-09 Karl DeBisschop <kdebisschop@infoplease.com>
#  - setup for autoconf
#  - add reload function
# 1999-08-06 Ethan Galstad <egalstad@nagios.org>
#  - Added configuration info for use with RedHat's chkconfig tool
#    per Fran Boon's suggestion
# 1999-08-13 Jim Popovitch <jimpop@rocketship.com>
#  - added variable for nagios/var directory
#  - cd into nagios/var directory before creating tmp files on startup
# 1999-08-16 Ethan Galstad <egalstad@nagios.org>
#  - Added test for rc.d directory as suggested by Karl DeBisschop
# 2000-07-23 Karl DeBisschop <kdebisschop@users.sourceforge.net>
#  - Clean out redhat macros and other dependencies
# 2003-01-11 Ethan Galstad <egalstad@nagios.org>
#  - Updated su syntax (Gary Miller)
# 2009-07-11 Hendrik BÃ¤cker <andurin@process-zero.de>
#  - Rewrite ido2db init script, inspired by Sascha Runschke
#
#

prefix=@prefix@
exec_prefix=${prefix}
Ido2dbBin=@bindir@/@ido2db_name@
Ido2dbCfgFile=@sysconfdir@/ido2db.cfg
Ido2dbRunFile=@IDO2DBLOCKFILE@
Ido2dbSockFile=@IDOSOCKFILE@
Ido2dbLockDir=/var/lock/subsys
Ido2dbLockFile=@ido2db_name@
Ido2dbUser=@icinga_user@
Ido2dbGroup=@icinga_grp@

#add ocilib lib path to link at runtime if enabled
LD_LIBRARY_PATH=$LD_LIBRARY_PATH:@ido2db_runtime@
export LD_LIBRARY_PATH


# load extra environment variables
if [ -f /etc/sysconfig/ido2db ]; then
    . /etc/sysconfig/ido2db
fi


# Source function library
# Solaris doesn't have an rc.d directory, so do a test first
if [ -f /etc/rc.d/init.d/functions ]; then
    . /etc/rc.d/init.d/functions
elif [ -f /etc/init.d/functions ]; then
    . /etc/init.d/functions
fi


# Check that ido2db binary exists.
if [ ! -f $Ido2dbBin ]; then
    echo "Executable file $Ido2dbBin not found.  Exiting."
    exit 1
fi

# Check that ido2db.cfg exists.
if [ ! -f $Ido2dbCfgFile ]; then
    echo "Configuration file $Ido2dbCfgFile not found.  Exiting."
    exit 1
fi

# Check that
if [ ! -d $Ido2dbLockDir ]; then
    echo "Lockfile dir $Ido2dbLockDir not found.  Exiting."
    exit 1
fi

## helper functions ##

# checks status if ido2db daemon
# return 0 if running
# return 1 if dead but pidfile exists
# return 3 if daemon is not running
# return 4 if the state is unknown
status_ido2db ()
{
    if pid_ido2db && process_ido2db; then
        return 0
    elif ! pid_ido2db && ! process_ido2db; then
        return 3
    elif pid_ido2db; then
        return 1
    else
        return 4
    fi
}

# print human readable output of service status
printstatus_ido2db()
{
    status_ido2db
    STATUS=$?
    if test $STATUS -eq 0; then
        echo "Ido2db (pid $Ido2dbPID) is running..."
    elif test $STATUS -eq 1; then
        echo "Ido2db is not running but subsystem locked"
    else
        echo "Ido2db is not running"
    fi
    exit $STATUS
}

# check if process is running
process_ido2db ()
{
    if ps -p $Ido2dbPID > /dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# check pidfile for existence
pid_ido2db ()
{
    if test -f $Ido2dbRunFile; then
        Ido2dbPID=`head -n 1 $Ido2dbRunFile`
        return 0
    else
        return 1
    fi
}

# send TERM signal if process is running
killproc_ido2db ()
{
	kill $Ido2dbPID
}

# send KILL signal
killproc9_ido2db ()
{
    kill -9 $Ido2dbPID

}

remove_run_files ()
{
    rm -f $Ido2dbRunFile $Ido2dbLockDir/$Ido2dbLockFile
}

## MAIN ##
# See how we were called.
case "$1" in

	start)
		#check if ido2db is already running
		status_ido2db
		STATUS=$?
		if test $STATUS -eq 0; then
            echo "Ido2db is already running. PID: $Ido2dbPID"
			exit 0
		elif test $STATUS -eq 1; then
			echo "Ido2db PID $Ido2dbPID not running. Removing lockfile."
			remove_run_files
		fi

		printf "Starting Ido2db:"
		# remove leftover sockfile, from a system crash
		rm -f $Ido2dbSockFile

        # precreate runfile and handover it to ido2db runuser and group
		touch $Ido2dbRunFile
        chown $Ido2dbUser:$Ido2dbGroup $Ido2dbRunFile

        # start ido2db daemon
		$Ido2dbBin -c $Ido2dbCfgFile
		touch $Ido2dbLockDir/$Ido2dbLockFile
		echo " done."
		exit 0
		;;

	stop)
	    if status_ido2db; then
	        printf "Stopping Ido2db: "
        	killproc_ido2db

         	# now we have to wait for ido2db to exit and remove its
         	# own Ido2dbRunFile, otherwise a following "start" could
         	# happen, and then the exiting ido2db will remove the
         	# new Ido2dbRunFile, allowing multiple ido2db daemons
         	# to (sooner or later) run - John Sellens
         	for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15; do
         	    if status_ido2db; then
         		printf '.'
         		sleep 1
         	    else
         		break
         	    fi
         	done
         	if status_ido2db; then
         	    echo ''
         	    echo "Warning - Ido2db did not exit in a timely manner. Sending kill -9"
        	    kill9proc_ido2db
         	else
         	    remove_run_files
         	    echo "done."
         	fi
	    else
	        echo "Ido2db is already stopped!"
	        exit 0
	    fi
		;;

    status)
		printstatus_ido2db
        ;;

	restart)
		$0 stop
		$0 start
		;;

	*)
		echo "Usage: Ido2db {start|stop|restart|status}"
		exit 1
		;;

esac
  
# End of this script
